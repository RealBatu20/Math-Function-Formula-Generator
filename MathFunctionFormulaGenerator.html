<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Infinite Voxel Math Explorer</title>
    <style>
        :root {
            --bg: #121212;
            --panel: #1e1e24;
            --border: #333;
            --accent: #50fa7b; /* Green */
            --accent-hover: #40c963;
            --delete: #ff5555;
            --delete-hover: #ff0000;
            --save: #f1fa8c; /* Yellow */
            --save-hover: #ffffa5;
            --tag-noise: #bd93f9; /* Purple */
            --tag-type: #8be9fd; /* Cyan */
            --tag-name: #ff79c6; /* Pink */
            --text: #f8f8f2;
            --text-mute: #8b9bb4;
            --font-mono: 'Consolas', 'Monaco', monospace;
            --font-ui: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: var(--font-ui);
            background-color: var(--bg);
            color: var(--text);
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        /* LAYOUT */
        #app-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* CANVAS AREA */
        #viewport {
            flex: 1;
            position: relative;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 100%);
            overflow: hidden;
            cursor: move;
        }

        /* OVERLAY CONTROLS */
        .overlay-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .overlay-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--border);
            color: var(--accent);
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
        }

        .overlay-btn:hover { background: rgba(0, 0, 0, 0.8); border-color: var(--accent); }
        .overlay-btn.active { background: var(--accent); color: #000; }

        /* ZOOM SLIDER */
        #zoom-container {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            height: 200px;
            width: 40px;
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 0;
            z-index: 10;
            backdrop-filter: blur(4px);
            border: 1px solid var(--border);
        }
        
        input[type=range][orient=vertical] {
            writing-mode: bt-lr; /* IE */
            -webkit-appearance: slider-vertical; /* WebKit */
            width: 8px;
            height: 100%;
            padding: 0 5px;
        }

        .zoom-label {
            font-size: 0.6rem;
            color: var(--text);
            margin-top: 5px;
            font-weight: bold;
        }

        /* BOTTOM CONTROL BAR */
        #controls {
            height: auto;
            min-height: 180px;
            background: var(--panel);
            border-top: 1px solid var(--border);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 20;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
        }

        .bar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            color: var(--text-mute);
            font-weight: bold;
            text-transform: uppercase;
            flex-wrap: wrap;
            gap: 10px;
        }

        .tags-container {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .info-tag {
            padding: 3px 8px;
            border-radius: 4px;
            color: #000;
            font-weight: 700;
            font-size: 0.7rem;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        #tag-noise { background: var(--tag-noise); }
        #tag-gen { background: var(--tag-type); }
        #tag-name { background: var(--tag-name); }

        textarea#formula-input {
            width: 100%;
            height: 50px;
            background: #000;
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-family: var(--font-mono);
            font-size: 0.8rem;
            padding: 10px;
            resize: none;
            outline: none;
            transition: border-color 0.2s;
        }
        textarea#formula-input:focus { border-color: var(--accent); }

        #error-msg {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: #ff5555;
            min-height: 18px;
            font-weight: bold;
        }

        .btn-row { display: flex; gap: 10px; margin-top: 5px; }

        button {
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.8rem;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
            text-transform: uppercase;
        }
        button:active { transform: scale(0.98); }

        .btn-primary { background: var(--accent); color: #000; flex: 2; }
        .btn-primary:hover { background: var(--accent-hover); }

        .btn-secondary { background: #383a59; color: var(--text); flex: 1; }
        .btn-secondary:hover { background: #44475a; }

        .btn-save { background: var(--save); color: #000; flex: 0.5; min-width: 80px;}
        .btn-save:hover { background: var(--save-hover); }

        /* SIDEBAR */
        #sidebar {
            position: absolute;
            top: 0; left: 0; bottom: 0;
            width: 360px;
            background: #16161a;
            border-right: 1px solid var(--border);
            transform: translateX(-100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 50;
            display: flex;
            flex-direction: column;
            box-shadow: 5px 0 25px rgba(0,0,0,0.5);
        }
        #sidebar.open { transform: translateX(0); }

        .sidebar-header {
            padding: 15px;
            border-bottom: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .sidebar-controls { display: flex; justify-content: space-between; align-items: center; }
        .close-sidebar { background: none; color: var(--text-mute); padding: 5px; cursor: pointer; font-size: 1.2rem;}

        .tab-row { display: flex; gap: 5px; background: #000; padding: 4px; border-radius: 6px;}
        .tab-btn { flex: 1; padding: 8px; font-size: 0.75rem; background: transparent; color: #888; border-radius: 4px;}
        .tab-btn.active { background: #333; color: #fff; }

        #sidebar-content { flex: 1; overflow-y: auto; padding: 10px; }

        .history-item {
            background: #25252b;
            margin-bottom: 8px;
            border-radius: 4px;
            border-left: 3px solid transparent;
            transition: background 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-right: 5px;
        }
        .history-item:hover { background: #2f2f36; border-left-color: var(--accent); }

        .history-content { padding: 12px; flex: 1; cursor: pointer; overflow: hidden; }
        
        .history-delete {
            background: none; border: none; color: var(--delete);
            font-size: 1.2rem; cursor: pointer; padding: 0 10px;
            height: 100%; display: flex; align-items: center; opacity: 0.7;
        }
        .history-delete:hover { opacity: 1; color: var(--delete-hover); }

        .h-tags { margin-bottom: 6px; display: flex; gap: 5px; flex-wrap: wrap; }
        .h-badge { font-size: 0.65rem; padding: 2px 5px; border-radius: 3px; color: #000; font-weight: bold; }
        .h-badge.n { background: var(--tag-noise); }
        .h-badge.t { background: var(--tag-type); }

        .h-name { 
            display: block; color: var(--tag-name); font-weight: bold; font-size: 0.75rem; margin-bottom: 2px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .h-code { 
            font-family: var(--font-mono); color: var(--text-mute); 
            display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 
            font-size: 0.7rem; 
        }

        /* TOAST */
        #toast {
            position: absolute; bottom: 220px; left: 50%;
            transform: translateX(-50%); background: var(--text); color: #000;
            padding: 8px 16px; border-radius: 20px; font-weight: bold;
            font-size: 0.8rem; opacity: 0; pointer-events: none;
            transition: opacity 0.3s; z-index: 100;
        }
        
        @media (min-width: 768px) { #controls { padding: 15px 30px; } }
    </style>
    <!-- THREE.JS IMPORT MAP -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="app-container">
        <div id="viewport">
            <div class="overlay-controls">
                <button id="reset-cam" class="overlay-btn">
                    ⟲ RESET
                </button>
                <button id="toggle-rotate" class="overlay-btn active">
                    <span>↻</span> AUTO ROTATE
                </button>
            </div>
            
            <!-- ZOOM SLIDER -->
            <div id="zoom-container">
                <input type="range" id="zoom-slider" orient="vertical" min="0" max="100" value="50">
                <div class="zoom-label">ZOOM</div>
            </div>

            <div id="toast">COPIED</div>
        </div>

        <div id="controls">
            <div class="bar-header">
                <div class="tags-container">
                    <span id="tag-noise" class="info-tag">SYSTEM</span>
                    <span id="tag-gen" class="info-tag">READY</span>
                    <span id="tag-name" class="info-tag">INITIALIZING</span>
                </div>
                <span style="font-size:0.7rem; opacity:0.5;">INFINITE VOXEL GEN</span>
            </div>
            
            <textarea id="formula-input" spellcheck="false" placeholder="Click GENERATE or type math formula..."></textarea>
            <div id="error-msg"></div>

            <div class="btn-row">
                <button class="btn-secondary" id="sidebar-toggle">History / Saved</button>
                <button class="btn-save" id="save-btn">★ Save</button>
                <button class="btn-secondary" id="copy-btn">Copy</button>
                <button class="btn-primary" id="gen-btn">GENERATE NEW</button>
            </div>
        </div>
    </div>

    <aside id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-controls">
                <span>LIBRARY</span>
                <button class="close-sidebar" id="close-sidebar">✕</button>
            </div>
            <div class="tab-row">
                <button class="tab-btn active" id="tab-history">HISTORY</button>
                <button class="tab-btn" id="tab-saved">CUSTOM SAVED</button>
            </div>
        </div>
        <div id="sidebar-content"></div>
    </aside>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==========================================
        // 1. MATH ENGINE IMPLEMENTATION
        // ==========================================
        
        const Noise = {
            perm: new Uint8Array(512),
            seed: function() {
                const p = new Uint8Array(256);
                for(let i=0; i<256; i++) p[i] = i;
                for(let i=0; i<256; i++) {
                    let r = Math.floor(Math.random()*256);
                    let t = p[i]; p[i] = p[r]; p[r] = t;
                }
                for(let i=0; i<512; i++) this.perm[i] = p[i & 255];
            },
            grad3: [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]],
            dot: (g, x, y) => g[0]*x + g[1]*y,
            simplex: function(x, y) {
                const F2 = 0.5*(Math.sqrt(3.0)-1.0);
                const G2 = (3.0-Math.sqrt(3.0))/6.0;
                let n0, n1, n2;
                let s = (x+y)*F2; 
                let i = Math.floor(x+s); let j = Math.floor(y+s);
                let t = (i+j)*G2;
                let X0 = i-t; let Y0 = j-t;
                let x0 = x-X0; let y0 = y-Y0;
                let i1, j1;
                if(x0>y0){i1=1; j1=0;}else{i1=0; j1=1;}
                let x1 = x0 - i1 + G2; let y1 = y0 - j1 + G2;
                let x2 = x0 - 1.0 + 2.0 * G2; let y2 = y0 - 1.0 + 2.0 * G2;
                let ii = i & 255; let jj = j & 255;
                let gi0 = this.perm[ii+this.perm[jj]] % 12;
                let gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12;
                let gi2 = this.perm[ii+1+this.perm[jj+1]] % 12;
                let t0 = 0.5 - x0*x0 - y0*y0;
                if(t0<0) n0 = 0.0; else {t0 *= t0; n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);}
                let t1 = 0.5 - x1*x1 - y1*y1;
                if(t1<0) n1 = 0.0; else {t1 *= t1; n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);}
                let t2 = 0.5 - x2*x2 - y2*y2;
                if(t2<0) n2 = 0.0; else {t2 *= t2; n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);}
                return 70.0 * (n0 + n1 + n2);
            }
        };
        Noise.seed();

        const Ctx = {
            // CONSTANTS
            pi: Math.PI, 'π': Math.PI, e: Math.E, phi: 1.618033988749895, 'φ': 1.618033988749895,
            zeta3: 1.202056903159594, 'ζ3': 1.202056903159594, catalan: 0.915965594177219, 'K': 0.915965594177219,
            alpha: 2.502907875095892, 'α': 2.502907875095892, delta: 4.669201609102990, 'δ': 4.669201609102990,
            omega: 0.6889, 'Ω': 0.6889,

            // TRIG
            sin: Math.sin, cos: Math.cos, tan: Math.tan,
            csc: x => 1 / Math.sin(x), sec: x => 1 / Math.cos(x), cot: x => 1 / Math.tan(x),
            asin: Math.asin, acos: Math.acos, atan: Math.atan, atan2: Math.atan2,
            acsc: x => Math.asin(1/x), asec: x => Math.acos(1/x), acot: x => Math.atan(1/x),

            // HYPER
            sinh: Math.sinh, cosh: Math.cosh, tanh: Math.tanh,
            csch: x => 1/Math.sinh(x), sech: x => 1/Math.cosh(x), coth: x => 1/Math.tanh(x),
            asinh: Math.asinh, acosh: Math.acosh, atanh: Math.atanh,
            acsch: x => Math.asinh(1/x), asech: x => Math.acosh(1/x), acoth: x => Math.atanh(1/x),

            // ROOT & POWER
            sqrt: Math.sqrt, cbrt: Math.cbrt, root: (x, n) => Math.pow(x, 1/n), pow: Math.pow, exp: Math.exp,

            // LOG
            ln: Math.log, lg: Math.log10,

            // NUMBERS
            abs: Math.abs, floor: Math.floor, ceil: Math.ceil, round: Math.round,
            sign: Math.sign, mod: (x, y) => x % y,
            gcd: (x, y) => { x = Math.abs(x); y = Math.abs(y); while(y){var t=y; y=x%y; x=t;} return x; },
            lcm: (x, y) => (!x||!y) ? 0 : Math.abs((x*y)/Ctx.gcd(x,y)),
            modi: (x, m) => (1/x)%m,

            // SPECIAL
            gamma: (z) => { 
                const g=7, p=[0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
                if(z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * Ctx.gamma(1 - z));
                z -= 1; let x = p[0]; for(let i=1; i<p.length; i++) x += p[i] / (z + i);
                const t = z + g + 0.5; return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
            },
            erf: (x) => {
                let sign = (x >= 0) ? 1 : -1; x = Math.abs(x);
                let a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429, p=0.3275911;
                let t = 1.0/(1.0 + p*x);
                return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x));
            },
            beta: (x, y) => Ctx.gamma(x) * Ctx.gamma(y) / Ctx.gamma(x + y),

            // RANDOM
            rand: Math.random,
            randnormal: (mean, stdev) => {
                let u=0, v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
                return (Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v)) * (stdev||1) + (mean||0);
            },
            randrange: (min, max) => Math.random() * (max - min) + min,

            // NOISE
            perlin: (x, y, z) => Noise.simplex(x, z), 
            simplex: (x, y, z) => Noise.simplex(x, z),
            normal: (x, y, z) => Ctx.randnormal(0, 1),
            blended: (x, y, z) => (Noise.simplex(x, z) + Math.sin(x)*Math.cos(z))/2,
            octaved: (x, z, oct, per) => {
                let total = 0, amp = 1, freq = 1, max = 0;
                for(let i=0; i<(oct||4); i++){
                    total += Noise.simplex(x*freq, z*freq)*amp;
                    max += amp; amp *= (per||0.5); freq *= 2;
                }
                return total/max;
            },

            // UTIL
            max: Math.max, min: Math.min,
            sigmoid: x => 1 / (1 + Math.exp(-x)),
            clamp: (x, mn, mx) => Math.min(Math.max(x, mn), mx)
        };

        // ==========================================
        // 2. GENERATION ENGINE (COMPLEX)
        // ==========================================
        
        const G = {
            pick: (arr) => arr[Math.floor(Math.random() * arr.length)],
            num: (min, max) => (Math.random() * (max - min) + min).toFixed(3),

            // Complex name generator
            getName: function(type) {
                const adj = ['Eternal', 'Broken', 'Infinite', 'Lost', 'Divine', 'Chaos', 'Neon', 'Hollow', 'Floating', 'Deep'];
                const noun = ['Realm', 'Void', 'Spire', 'Nexus', 'Grid', 'Valley', 'Core', 'Sanctuary', 'Matrix', 'Abyss'];
                return `${this.pick(adj)} ${this.pick(noun)}`;
            },

            getNoise: function(type, s) {
                if(type==='PERLIN') return `perlin(x*${s},0,z*${s})`;
                if(type==='SIMPLEX') return `simplex(x*${s},0,z*${s})`;
                if(type==='NORMAL') return `randnormal(0,1)`;
                if(type==='BLENDED') return `blended(x*${s},0,z*${s})`;
                if(type==='OCTAVED') return `octaved(x*${s},z*${s},4,0.5)`;
                return `perlin(x*${s},0,z*${s})`;
            },

            create: function() {
                const nType = this.pick(this.noiseTypes);
                const gType = this.pick(this.genTypes);
                
                // AUTO SCALE BLOCK COORDS
                // Randomized scale between 0.005 (huge) to 0.15 (tight)
                const s = this.num(0.005, 0.15); 
                const base = this.getNoise(nType, s);
                let f = "";

                // EXPERT / LONG / UNREAL MATH
                // We add complexity with random modifiers
                const mod = Math.random();
                let extraMath = "";
                
                if (mod > 0.7) { // Unreal Math (Complex Trig)
                    extraMath = ` + sin(x*${this.num(0.01,0.05)}) * cos(z*${this.num(0.01,0.05)}) * 10`;
                } else if (mod > 0.4) { // Expert Math (Fractal-ish)
                    extraMath = ` + abs(mod(x, 20) - 10) * 0.5`;
                }

                switch (gType) {
                    case 'MAZE': f = `floor(abs(sin(x*${s}) + cos(z*${s}))) * 10`; break;
                    case 'GIANT MAZE': f = `floor(abs(sin(x*${s/2}) + cos(z*${s/2})) * 0.9) * 20`; break;
                    case 'AUTO MAZE': f = `floor(abs(perlin(x*${s}, 0, z*${s})) * 2) * 5`; break;
                    case 'BLOCKY': f = `floor(${base} * 5) * 4 ${extraMath}`; break;
                    case 'SMOOTH': f = `sigmoid(${base}) * 20 ${extraMath}`; break;
                    case 'UPWARDS': f = `${base} * 5 + (x*0.1 + z*0.1)`; break;
                    case 'DOWNWARD': f = `${base} * 5 - (x*0.1 + z*0.1)`; break;
                    case 'REVERSE': f = `(${base} * 10) * -1`; break;
                    case 'FORWARD': f = `${base} * 5 + z * 0.5`; break;
                    case 'FLIPX': f = `sin(-x * 0.2) * 5 + ${base}*5`; break;
                    case 'FLIPY': f = `(${base} * 15) * -1`; break;
                    case 'FLIPZ': f = `cos(-z * 0.2) * 5 + ${base}*5`; break;
                    case 'TOWER': f = `max(0, 30 - sqrt(x*x + z*z)) * 2`; break;
                    case 'SKYSCRAPER': f = `max(0, sin(x*0.2)*sin(z*0.2)) * 60`; break;
                    case 'HOLES': f = `15 - max(0, sin(x*0.1)*sin(z*0.1)*30)`; break;
                    case 'CAVERN': f = `abs(${base} * 15) * -1 + 10 ${extraMath}`; break;
                    case 'FANTASY': f = `sin(x*0.05)*cos(z*0.05)*15 + pow(abs(${base}), 3)*15`; break;
                    case 'UNDERWATER': f = `min(-5, ${base} * 20)`; break;
                    case 'HELL': f = `abs(tan(${base})) * 8`; break;
                    case 'REALISTIC': f = `octaved(x*0.005, z*0.005, 6, 0.5) * 40`; break;
                    case 'ONE BLOCK': f = `floor(max(0, 2 - sqrt(x*x+z*z))) * 10`; break;
                    case 'X-RAY': f = `mod(floor(x), 8) * mod(floor(z), 8) * 5`; break;
                    case 'SPHERE': f = `sqrt(max(0, 900 - x*x - z*z))`; break;
                    case 'CUBES': f = `floor(x/10)*5 + floor(z/10)*5 + ${base}*5`; break;
                    case 'PYRAMID': f = `max(0, 40 - max(abs(x), abs(z)))`; break;
                    case 'TORUS': f = `sqrt(max(0, 100 - pow(sqrt(x*x+z*z) - 30, 2)))`; break;
                    case 'STAR': f = `max(0, 20 - sqrt(x*x+z*z) + sin(atan2(z,x)*5)*10)`; break;
                    case 'NOTCH': f = `perlin(x*0.01, 0, z*0.01) * 20 + octaved(x*0.05,z*0.05,2,0.5)*5`; break;
                    case 'UNDERWORLD': f = `${base} * 5 - 30 ${extraMath}`; break;
                    case 'FLOATING': f = `${base} * 5 + 30 ${extraMath}`; break;
                    case 'FLOATING ISLAND': f = `max(0, 30 - sqrt(x*x+z*z)) + ${base}*5 + 15`; break;
                    case 'UPSIDE DOWN': f = `(${base}*10 + 20) * -1`; break;
                    case 'DIGITAL': f = `round(${base} * 5) * 4`; break;
                    case 'MODERN': f = `max(abs(x), abs(z)) * 0.2 ${extraMath}`; break;
                    case 'CYBERPUNK2077': f = `mod(floor(x), 10) * mod(floor(z), 10) * 5 + ${base}*5 + sin(x)*5`; break;
                    default: f = `${base} * 15`; break;
                }

                // Append Logic for "Long Math" randomly
                if (Math.random() > 0.8) {
                    f = `(${f}) + sin(x*0.1)*cos(z*0.1)*5 - abs(x*0.05)`;
                }

                const name = this.getName();
                return { noise: nType, type: gType, name: name, formula: f };
            },

            noiseTypes: ['PERLIN', 'SIMPLEX', 'NORMAL', 'BLENDED', 'OCTAVED'],
            genTypes: [
                'MAZE', 'GIANT MAZE', 'AUTO MAZE',
                'BLOCKY', 'SMOOTH', 'UPWARDS', 'DOWNWARD', 'REVERSE', 'FORWARD', 
                'FLIPX', 'FLIPY', 'FLIPZ', 'TOWER', 'SKYSCRAPER', 'HOLES', 
                'CAVERN', 'FANTASY', 'UNDERWATER', 'HELL', 'REALISTIC', 'ONE BLOCK', 
                'X-RAY', 'SPHERE', 'CUBES', 'PYRAMID', 'TORUS', 'STAR', 'NOTCH', 
                'UNDERWORLD', 'FLOATING', 'FLOATING ISLAND', 'UPSIDE DOWN', 
                'DIGITAL', 'MODERN', 'CYBERPUNK2077'
            ]
        };

        // ==========================================
        // 3. THREE.JS SCENE (INFINITE ENGINE)
        // ==========================================
        
        const container = document.getElementById('viewport');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 60, 220); // Fog creates the illusion of distance

        const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 1, 500);
        
        // ZOOM SLIDER LOGIC
        // 0% = 10 units, 100% = 200 units
        let camDistMin = 10;
        let camDistMax = 200;
        let currentZoomPct = 0.5;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; 
        controls.dampingFactor = 0.05; 
        controls.rotateSpeed = 0.6;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        // We override zoom control with slider, but mouse wheel still works 
        // to update the slider indirectly or fine tune.
        controls.enableZoom = true; 

        // Lighting
        const ambi = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambi);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(50, 80, 50);
        dirLight.castShadow = true;
        // Large shadow map for infinite feel
        dirLight.shadow.mapSize.width = 2048; 
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 300;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);

        // INFINITE VOXEL SYSTEM
        // We render a fixed grid around the center (0,0,0)
        // But we shift the math evaluation based on camera position
        const GRID = 80; // Render distance (80x80 blocks)
        const LAYERS = 4;
        const TOTAL_INSTANCES = GRID * GRID * LAYERS;

        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            roughness: 0.9,
            metalness: 0.1
        });
        
        const instMesh = new THREE.InstancedMesh(geometry, material, TOTAL_INSTANCES);
        instMesh.castShadow = true;
        instMesh.receiveShadow = true;
        scene.add(instMesh);

        const dummy = new THREE.Object3D();
        const color = new THREE.Color();
        
        const colors = {
            water: new THREE.Color(0x3273a8),
            sand: new THREE.Color(0xdec28a),
            grass: new THREE.Color(0x56a34c),
            dirt: new THREE.Color(0x795548),
            stone: new THREE.Color(0x808080),
            snow: new THREE.Color(0xffffff),
            alien: new THREE.Color(0x9c27b0),
            lava: new THREE.Color(0xff5722),
            neon: new THREE.Color(0x00e5ff)
        };

        // Global state for infinite generation
        let currentFuncStr = "";
        let currentFunc = null;
        let worldOffsetX = 0;
        let worldOffsetZ = 0;
        let lastGridX = 0;
        let lastGridZ = 0;

        function updateTerrain() {
            if(!currentFunc) return;

            let idx = 0;
            const offset = GRID / 2;
            
            // worldOffset comes from camera position logic
            const startX = worldOffsetX - offset;
            const startZ = worldOffsetZ - offset;

            for(let x = 0; x < GRID; x++) {
                for(let z = 0; z < GRID; z++) {
                    // Actual world coordinates
                    const wx = startX + x;
                    const wz = startZ + z;
                    
                    let y = 0;
                    try { y = currentFunc(Ctx, wx, wz); } catch(e) {}
                    if (isNaN(y) || !isFinite(y)) y = 0;

                    const surfaceY = Math.floor(y);
                    
                    let biomeType = 'GRASS';
                    if (surfaceY < -2) biomeType = 'WATER';
                    else if (surfaceY < 2) biomeType = 'SAND';
                    else if (surfaceY < 12) biomeType = 'GRASS';
                    else if (surfaceY < 20) biomeType = 'STONE';
                    else biomeType = 'SNOW';

                    // Contextual Biome Overrides
                    if (currentFuncStr.includes('mod') && surfaceY > 5) biomeType = 'NEON';
                    if (y > 40) biomeType = 'ALIEN';
                    if (y < -20) biomeType = 'LAVA';

                    for (let d = 0; d < LAYERS; d++) {
                        const currentY = surfaceY - d;
                        
                        // Local position relative to camera center effectively
                        // But we want to keep them static in world space visually
                        // We reset mesh position to align with world coords relative to 0
                        // Since we can't move 0,0,0, we move the blocks.
                        // Actually, for infinite scrolling, we usually move the camera.
                        // But here we keep camera local-ish and move blocks to simulate window.
                        // To allow OrbitControls to work naturally, we keep blocks at actual world pos?
                        // No, floating point errors.
                        // Trick: We put blocks at (wx - worldOffsetX, y, wz - worldOffsetZ) + local shift?
                        // Simplest: Just render at (wx, y, wz). ThreeJS handles float range well enough for this scale.
                        
                        dummy.position.set(wx, currentY, wz);
                        dummy.scale.set(1, 1, 1);
                        dummy.updateMatrix();
                        instMesh.setMatrixAt(idx, dummy.matrix);

                        let c = color;
                        if (d === 0) { 
                            if (biomeType === 'WATER') c.copy(colors.water);
                            else if (biomeType === 'SAND') c.copy(colors.sand);
                            else if (biomeType === 'GRASS') c.copy(colors.grass);
                            else if (biomeType === 'STONE') c.copy(colors.stone);
                            else if (biomeType === 'ALIEN') c.copy(colors.alien);
                            else if (biomeType === 'LAVA') c.copy(colors.lava);
                            else if (biomeType === 'NEON') c.copy(colors.neon);
                            else c.copy(colors.snow);
                        } 
                        else if (d === 1 || d === 2) { 
                            if (biomeType === 'WATER') c.copy(colors.water);
                            else if (biomeType === 'SAND') c.copy(colors.sand);
                            else if (biomeType === 'GRASS') c.copy(colors.dirt);
                            else c.copy(colors.stone);
                        } 
                        else c.copy(colors.stone);

                        if (d > 0) c.multiplyScalar(0.9 - (d * 0.05)); 

                        instMesh.setColorAt(idx, c);
                        idx++;
                    }
                }
            }
            instMesh.instanceMatrix.needsUpdate = true;
            instMesh.instanceColor.needsUpdate = true;
        }

        function compileAndRender(str) {
            currentFuncStr = str;
            try {
                const safeStr = str.replace(/\^/g, '**'); 
                currentFunc = new Function('ctx', 'x', 'z', `with(ctx) { try { return ${safeStr}; } catch(e){ return 0; } }`);
                
                // Clear errors
                ui.errorMsg.textContent = "";
                
                // Reset infinite offset on new gen? Optional. Let's keep position.
                // updateTerrain(); called in animate loop if moved
                updateTerrain(); 

            } catch(e) { 
                ui.errorMsg.textContent = "SYNTAX ERROR: " + e.message;
            }
        }

        // INFINITE LOGIC: Check if camera moved far enough to update grid center
        function checkInfiniteTerrain() {
            // Get camera look target or position
            // Simple approach: based on camera position X/Z
            // Round to nearest chunk size (e.g. 10 blocks)
            const cx = Math.floor(controls.target.x);
            const cz = Math.floor(controls.target.z);
            
            // If moved more than 5 blocks from last update center
            if (Math.abs(cx - lastGridX) > 5 || Math.abs(cz - lastGridZ) > 5) {
                worldOffsetX = cx;
                worldOffsetZ = cz;
                lastGridX = cx;
                lastGridZ = cz;
                updateTerrain();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            checkInfiniteTerrain();
            renderer.render(scene, camera);
        }
        
        // Setup initial Zoom
        function setZoom(val) {
            // val 0-100
            // Map to distance
            const dist = camDistMin + (val/100) * (camDistMax - camDistMin);
            
            // We need to adjust camera position relative to target to match distance
            // Get vector from target to camera
            const v = new THREE.Vector3().subVectors(camera.position, controls.target);
            v.setLength(dist);
            camera.position.copy(controls.target).add(v);
        }

        animate();

        // ==========================================
        // 4. UI LOGIC
        // ==========================================
        
        const ui = {
            input: document.getElementById('formula-input'),
            errorMsg: document.getElementById('error-msg'),
            tagNoise: document.getElementById('tag-noise'),
            tagGen: document.getElementById('tag-gen'),
            tagName: document.getElementById('tag-name'),
            
            btnGen: document.getElementById('gen-btn'),
            btnCopy: document.getElementById('copy-btn'),
            btnSave: document.getElementById('save-btn'),
            btnSidebar: document.getElementById('sidebar-toggle'),
            
            sidebar: document.getElementById('sidebar'),
            closeSidebar: document.getElementById('close-sidebar'),
            sidebarContent: document.getElementById('sidebar-content'),
            
            tabHistory: document.getElementById('tab-history'),
            tabSaved: document.getElementById('tab-saved'),
            
            toggleRot: document.getElementById('toggle-rotate'),
            resetCam: document.getElementById('reset-cam'),
            zoomSlider: document.getElementById('zoom-slider'),
            toast: document.getElementById('toast')
        };

        let historySet = new Set();
        let savedSet = new Set();
        let currentTab = 'HISTORY'; // 'HISTORY' or 'SAVED'

        // DATA OBJECTS
        const historyData = []; // Array of objects
        const savedData = [];

        function generateNew() {
            Noise.seed();
            const data = G.create();
            
            // Retry once for duplicate formulas
            if(historySet.has(data.formula)) {
                const retry = G.create();
                if(!historySet.has(retry.formula)) Object.assign(data, retry);
            }

            ui.input.value = data.formula;
            ui.tagNoise.textContent = data.noise;
            ui.tagGen.textContent = data.type;
            ui.tagName.textContent = data.name.toUpperCase();
            
            compileAndRender(data.formula);
            
            // Add to history
            if(!historySet.has(data.formula)) {
                historySet.add(data.formula);
                historyData.unshift(data);
                if(currentTab === 'HISTORY') renderSidebar();
            }
        }

        // SAVE LOGIC
        ui.btnSave.addEventListener('click', () => {
            const f = ui.input.value;
            if(!f) return;
            // Check if already saved
            if(savedSet.has(f)) {
                showToast("ALREADY SAVED");
                return;
            }
            
            // Create data object
            const data = {
                noise: ui.tagNoise.textContent,
                type: ui.tagGen.textContent,
                name: ui.tagName.textContent,
                formula: f
            };
            
            savedSet.add(f);
            savedData.unshift(data);
            showToast("SAVED TO LIBRARY");
            
            if(currentTab === 'SAVED') renderSidebar();
        });

        // SIDEBAR RENDERING
        function renderSidebar() {
            ui.sidebarContent.innerHTML = '';
            const list = (currentTab === 'HISTORY') ? historyData : savedData;
            
            list.forEach((data, index) => {
                const item = document.createElement('div');
                item.className = 'history-item';
                
                const content = document.createElement('div');
                content.className = 'history-content';
                content.innerHTML = `
                    <span class="h-name">${data.name}</span>
                    <div class="h-tags">
                        <span class="h-badge n">${data.noise}</span>
                        <span class="h-badge t">${data.type}</span>
                    </div>
                    <span class="h-code">${data.formula}</span>
                `;
                content.onclick = () => {
                    ui.input.value = data.formula;
                    ui.tagNoise.textContent = data.noise;
                    ui.tagGen.textContent = data.type;
                    ui.tagName.textContent = data.name;
                    compileAndRender(data.formula);
                };

                const delBtn = document.createElement('button');
                delBtn.className = 'history-delete';
                delBtn.innerHTML = '×';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    // Remove from array and set
                    if(currentTab === 'HISTORY') {
                        historyData.splice(index, 1);
                        historySet.delete(data.formula);
                    } else {
                        savedData.splice(index, 1);
                        savedSet.delete(data.formula);
                    }
                    renderSidebar();
                };

                item.appendChild(content);
                item.appendChild(delBtn);
                ui.sidebarContent.appendChild(item);
            });
        }

        // TAB SWITCHING
        ui.tabHistory.addEventListener('click', () => {
            currentTab = 'HISTORY';
            ui.tabHistory.classList.add('active');
            ui.tabSaved.classList.remove('active');
            renderSidebar();
        });

        ui.tabSaved.addEventListener('click', () => {
            currentTab = 'SAVED';
            ui.tabSaved.classList.add('active');
            ui.tabHistory.classList.remove('active');
            renderSidebar();
        });

        // INPUT LISTENER (Real-time)
        ui.input.addEventListener('input', () => {
            ui.tagGen.textContent = "CUSTOM";
            ui.tagName.textContent = "USER EDITED";
            compileAndRender(ui.input.value);
        });

        // ZOOM SLIDER LISTENER
        ui.zoomSlider.addEventListener('input', (e) => {
            setZoom(e.target.value);
        });

        // CAMERA CONTROLS
        let isRotating = true;
        ui.toggleRot.addEventListener('click', () => {
            isRotating = !isRotating;
            controls.autoRotate = isRotating;
            ui.toggleRot.classList.toggle('active', isRotating);
        });

        ui.resetCam.addEventListener('click', () => {
            camera.position.set(INITIAL_CAM_POS.x, INITIAL_CAM_POS.y, INITIAL_CAM_POS.z);
            controls.target.set(0, 0, 0);
            ui.zoomSlider.value = 50;
            controls.update();
        });

        // COPY
        ui.btnCopy.addEventListener('click', () => {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(ui.input.value).then(() => showToast("COPIED"));
            } else {
                ui.input.select();
                document.execCommand('copy');
                showToast("COPIED");
            }
        });

        function showToast(msg) {
            ui.toast.textContent = msg;
            ui.toast.style.opacity = 1;
            setTimeout(() => ui.toast.style.opacity = 0, 1500);
        }

        // SIDEBAR TOGGLE
        ui.btnSidebar.addEventListener('click', () => ui.sidebar.classList.add('open'));
        ui.closeSidebar.addEventListener('click', () => ui.sidebar.classList.remove('open'));
        ui.btnGen.addEventListener('click', generateNew);

        // RESIZE
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        // INIT
        generateNew();
        setZoom(50); // Set initial zoom based on slider default

    </script>
</body>
</html>